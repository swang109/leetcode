#include<iostream>
#include<vector>
using namespace std;

class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> v(1,1);
        int i2=0,i3=0,i5=0;
        while(v.size()<n){
            v.push_back(min(v[i2]*2,min(v[i3]*3,v[i5]*5)));
            if(v.back()==v[i2]*2) i2++;
            if(v.back()==v[i3]*3) i3++;
            if(v.back()==v[i5]*5) i5++;
        }
        return v.back();
    }
};

int main(){
   Solution solution;
   cout<<solution.nthUglyNumber(10)<<'\n';
}

/*
use existing num to time 2,3,5 and find the minimum


The key is to realize each number can be and have to be generated by a former number multiplied by 2, 3 or 5 e.g. 1 2 3 4 5 6 8 9 10 12 15.. what is next? it must be x * 2 or y * 3 or z * 5, where x, y, z is an existing number.

How do we determine x, y, z then? apparently, you can just traverse the sequence generated by far from 1 ... 15, until you find such x, y, z that x * 2, y * 3, z * 5 is just bigger than 15. In this case x=8, y=6, z=4. Then you compare x * 2, y * 3, z * 5 so you know next number will be x * 2 = 8 * 2 = 16. k, now you have 1,2,3,4,....,15, 16,

Then what is next? You wanna do the same process again to find the new x, y, z, but you realize, wait, do I have to traverse the sequence generated by far again?

NO! since you know last time, x=8, y=6, z=4 and x=8 was used to generate 16, so this time, you can immediately know the newx = 9 (the next number after 8 is 9 in the generated sequence), y=6, z=4. Then you need to compare newx * 2, y * 3, z * 5. You know next number is 9 * 2 = 18;

And you also know, the next x will be 10 since new_x = 9 was used this time. But what is next y? apparently, if y=6, 6*3 = 18, which is already generated in this round. So you also need to update next y from 6 to 8.

Based on the idea above, you can actually generated x,y,z from very beginning, and update x, y, z accordingly. It ends up with a O(n) solution.
*/
